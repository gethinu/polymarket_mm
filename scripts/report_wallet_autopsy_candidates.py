#!/usr/bin/env python3
"""
Summarize wallet autopsy top-holder outputs in logs/ and extract candidate wallets.

Input files are generated by:
  python scripts/analyze_user.py "<market query>" --top-holders N
"""

from __future__ import annotations

import argparse
import datetime as dt
import json
from pathlib import Path
from typing import Iterable, List


def parse_iso_dt(value: str) -> dt.datetime:
    try:
        return dt.datetime.fromisoformat(str(value).replace("Z", "+00:00"))
    except Exception:
        return dt.datetime.min.replace(tzinfo=dt.timezone.utc)


def iter_target_files(logs_dir: Path, pattern: str) -> Iterable[Path]:
    for p in sorted(logs_dir.glob(pattern)):
        if p.is_file():
            yield p


def load_json(path: Path):
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return None


def repo_root() -> Path:
    return Path(__file__).resolve().parents[1]


def main() -> int:
    p = argparse.ArgumentParser(description="Summarize autopsy top-holder candidates from logs/")
    p.add_argument("--glob", default="autopsy_*_top*.json", help="Glob pattern under logs/")
    p.add_argument(
        "--statuses",
        default="ARBITRAGE_CANDIDATE,PARTIAL_HEDGE",
        help="Comma-separated hedge statuses to include",
    )
    p.add_argument("--min-profitable-pct", type=float, default=0.0, help="Minimum time-profitable pct")
    p.add_argument("--min-trades", type=int, default=1, help="Minimum trade count")
    p.add_argument("--latest-per-market", action="store_true", help="Keep only latest scan file per market")
    p.add_argument("--top", type=int, default=50, help="Max rows to print")
    p.add_argument("--out", default="", help="Optional output JSON path (simple filename => logs/)")
    args = p.parse_args()

    logs_dir = repo_root() / "logs"
    logs_dir.mkdir(parents=True, exist_ok=True)
    allowed = {s.strip() for s in args.statuses.split(",") if s.strip()}

    files = list(iter_target_files(logs_dir, args.glob))
    if not files:
        print(f"No files matched: {logs_dir / args.glob}")
        return 1

    selected_files: List[Path] = []
    if args.latest_per_market:
        latest_by_market = {}
        for fp in files:
            obj = load_json(fp)
            if not isinstance(obj, dict):
                continue
            meta = obj.get("meta") if isinstance(obj.get("meta"), dict) else {}
            market = meta.get("market") if isinstance(meta.get("market"), dict) else {}
            key = str(market.get("condition_id") or market.get("market_slug") or fp.name)
            gen = parse_iso_dt(str(meta.get("generated_at_utc") or ""))
            prev = latest_by_market.get(key)
            if prev is None or gen >= prev[0]:
                latest_by_market[key] = (gen, fp)
        selected_files = [v[1] for v in latest_by_market.values()]
    else:
        selected_files = files

    rows = []
    for fp in selected_files:
        obj = load_json(fp)
        if not isinstance(obj, dict):
            continue
        meta = obj.get("meta") if isinstance(obj.get("meta"), dict) else {}
        market = meta.get("market") if isinstance(meta.get("market"), dict) else {}
        market_title = str(market.get("market_question") or market.get("event_title") or "")
        generated_at = str(meta.get("generated_at_utc") or "")
        summary = obj.get("summary")
        if not isinstance(summary, list):
            continue
        for r in summary:
            if not isinstance(r, dict):
                continue
            hedge_status = str(r.get("hedge_status") or "UNKNOWN")
            trades = int(r.get("trade_count") or 0)
            prof = r.get("time_profitable_pct")
            try:
                prof_f = float(prof) if prof is not None else None
            except (TypeError, ValueError):
                prof_f = None

            if allowed and hedge_status not in allowed:
                continue
            if trades < int(args.min_trades):
                continue
            if prof_f is not None and prof_f < float(args.min_profitable_pct):
                continue

            rows.append(
                {
                    "generated_at_utc": generated_at,
                    "market": market_title,
                    "wallet": str(r.get("wallet") or ""),
                    "rank": int(r.get("rank") or 0),
                    "trade_count": trades,
                    "time_profitable_pct": prof_f,
                    "combined_avg": r.get("combined_avg"),
                    "hedge_status": hedge_status,
                    "source_file": str(fp),
                }
            )

    rows.sort(
        key=lambda x: (
            0 if x.get("hedge_status") == "ARBITRAGE_CANDIDATE" else 1,
            -(float(x.get("time_profitable_pct") or 0.0)),
            int(x.get("rank") or 9999),
        )
    )

    print(f"Scanned files: {len(selected_files)}")
    print(f"Candidate rows: {len(rows)}")
    print("-" * 110)
    print(f"{'status':<20} {'prof%':>7} {'trades':>7} {'comb_avg':>9} {'wallet':<42} market")
    for r in rows[: max(1, int(args.top))]:
        prof = r.get("time_profitable_pct")
        prof_s = f"{float(prof):.1f}" if prof is not None else "-"
        comb = r.get("combined_avg")
        comb_s = f"{float(comb):.4f}" if comb is not None else "-"
        print(
            f"{str(r['hedge_status']):<20} {prof_s:>7} {int(r['trade_count']):>7} {comb_s:>9} "
            f"{str(r['wallet']):<42} {str(r['market'])}"
        )

    if args.out:
        out = Path(args.out)
        if not out.is_absolute():
            if len(out.parts) == 1:
                out = logs_dir / out.name
            else:
                out = repo_root() / out
        out.parent.mkdir(parents=True, exist_ok=True)
        payload = {
            "meta": {
                "generated_at_utc": dt.datetime.now(dt.timezone.utc).isoformat(),
                "glob": args.glob,
                "statuses": sorted(list(allowed)),
                "min_profitable_pct": float(args.min_profitable_pct),
                "min_trades": int(args.min_trades),
                "latest_per_market": bool(args.latest_per_market),
                "rows": len(rows),
            },
            "rows": rows,
        }
        with out.open("w", encoding="utf-8") as f:
            json.dump(payload, f, ensure_ascii=False, indent=2)
        print()
        print(f"Saved: {out}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())

